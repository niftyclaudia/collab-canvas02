# PR #1: Resize Shapes - Action Plan

## Goal
Add 8-handle resize UI with corner (proportional) and edge (single-dimension) controls; enable real-time sync across users

## PRD Reference
See `docs/prd.md` Section 1: "Resize Shapes (P0 - Critical)"

## Overview
This PR transforms the current visual-only resize handles into fully functional interactive handles. Users will be able to click and drag 8 handles (4 corners + 4 edges) to resize shapes with real-time preview and sync.

## Files to Create
None - all modifications to existing files

## Files to Modify

### 1. `src/services/canvasService.ts`
**Changes:**
- Add `resizeShape(shapeId: string, width: number, height: number): Promise<void>` method
- Validate minimum dimensions (10√ó10px)
- Update Firestore with new dimensions + timestamp

### 2. `src/components/Canvas/Canvas.tsx`
**Changes:**
- Add resize state management (activeHandle, resizeStart, previewDimensions)
- Implement 8 interactive resize handles (currently only 4 visual handles exist)
- Add handle hover effects (8√ó8px ‚Üí 10√ó10px, color change)
- Implement corner resize logic (proportional, maintains aspect ratio)
- Implement edge resize logic (single dimension)
- Add dimension tooltip component (shows during resize)
- Wire up mousedown/mousemove/mouseup handlers for resize
- Call canvasService.resizeShape() on mouseup

### 3. `src/utils/constants.ts`
**Changes:**
- Add `MIN_SHAPE_WIDTH = 10` constant
- Add `MIN_SHAPE_HEIGHT = 10` constant
- (Already has MIN_SHAPE_SIZE but we need specific width/height constants)

## Sub-Tasks with Test Gates

### Task 1.1: Add resizeShape to CanvasService ‚úÖ COMPLETED
**Estimated time:** 20 minutes
**Status:** ‚úÖ Implemented and tested successfully

**Implementation:**
```typescript
async resizeShape(shapeId: string, width: number, height: number): Promise<void> {
  // Validate minimum dimensions
  if (width < 10 || height < 10) {
    throw new Error('Minimum size is 10√ó10 pixels');
  }
  
  const shapeRef = doc(firestore, this.shapesCollectionPath, shapeId);
  await updateDoc(shapeRef, {
    width: width,
    height: height,
    updatedAt: serverTimestamp()
  });
}
```

**Test Gate:**
1. Open browser console
2. Run: `await canvasService.resizeShape('shape_id_here', 300, 200)`
3. Verify Firestore document updated with new width/height
4. Verify `updatedAt` timestamp changed
5. Try invalid dimensions (9√ó9) ‚Üí should throw error
6. Add log to console with [‚úÖ SUCCCESS TASK [`task-number`]]
6. Check console for error message

**Success Criteria:**
- Method exists and is callable
- Firestore updates correctly
- Validation prevents <10px dimensions
- Error thrown for invalid input

---

### Task 1.2: Resize Handle Rendering ‚úÖ COMPLETED
**Estimated time:** 30 minutes
**Status:** ‚úÖ Implemented with 8 handles and hover effects (visual only, not functional yet)

**Implementation:**
- Expand current 4-handle system to 8 handles
- Handle positions: TL (0,0), T (mid,0), TR (width,0), L (0,mid), R (width,mid), BL (0,height), B (mid,height), BR (width,height)
- Base style: 16px white squares, 1px gray border (scales inversely with zoom for consistent visibility)
- Hover style: 20px blue squares
- Handles scale inversely with zoom level so they always appear the same size on screen
- Only show when shape is locked by current user

**Handle position calculations:**
```typescript
const handles = [
  { x: -6, y: -6, cursor: 'nwse-resize', type: 'corner', name: 'tl' },
  { x: shape.width / 2 - 6, y: -6, cursor: 'ns-resize', type: 'edge', name: 't' },
  { x: shape.width - 6, y: -6, cursor: 'nesw-resize', type: 'corner', name: 'tr' },
  { x: -6, y: shape.height / 2 - 6, cursor: 'ew-resize', type: 'edge', name: 'l' },
  { x: shape.width - 6, y: shape.height / 2 - 6, cursor: 'ew-resize', type: 'edge', name: 'r' },
  { x: -6, y: shape.height - 6, cursor: 'nesw-resize', type: 'corner', name: 'bl' },
  { x: shape.width / 2 - 6, y: shape.height - 6, cursor: 'ns-resize', type: 'edge', name: 'b' },
  { x: shape.width - 6, y: shape.height - 6, cursor: 'nwse-resize', type: 'corner', name: 'br' },
];
```

**Test Gate:**
1. Lock a shape (click on it)
2. Verify 8 squares appear at all edges and corners
3. Count handles: 4 corners + 4 edges = 8 total
4. Visual inspection: handles are 16px white with gray border
5. Hover over each handle ‚Üí should grow to 20px and change to blue
6. Test zoom: Zoom in/out and verify handles stay same screen size
7. Click background ‚Üí handles disappear
8. Lock again ‚Üí handles reappear

**Success Criteria:**
- All 8 handles visible when shape locked
- Handles positioned correctly at corners and edge midpoints
- Hover effect works (size + color change)
- Handles only show for locked-by-me shapes

---

### Task 1.3: Corner Handle Resize Logic (Proportional) ‚úÖ COMPLETED
**Estimated time:** 45 minutes
**Status:** ‚úÖ Implemented - ready for testing

**Implementation:**
- Calculate aspect ratio on mousedown: `aspectRatio = originalWidth / originalHeight`
- During drag, maintain aspect ratio based on which corner is being dragged
- Handle all 4 corners: TL, TR, BL, BR
- Different corners require different calculations:
  - **TL:** Anchor BR, resize from top-left (width/height decrease)
  - **TR:** Anchor BL, resize from top-right (width increases, height decreases)
  - **BL:** Anchor TR, resize from bottom-left (width decreases, height increases)
  - **BR:** Anchor TL, resize from bottom-right (width/height increase)

**State needed:**
```typescript
const [isResizing, setIsResizing] = useState(false);
const [activeHandle, setActiveHandle] = useState<string | null>(null);
const [resizeStart, setResizeStart] = useState<{
  x: number;
  y: number;
  width: number;
  height: number;
  aspectRatio: number;
} | null>(null);
const [previewDimensions, setPreviewDimensions] = useState<{
  x: number;
  y: number;
  width: number;
  height: number;
} | null>(null);
```

**Resize calculation example (BR corner):**
```typescript
const dx = currentX - resizeStart.x;
const dy = currentY - resizeStart.y;

// Use the larger delta to maintain aspect ratio
const scale = Math.max(
  (resizeStart.width + dx) / resizeStart.width,
  (resizeStart.height + dy) / resizeStart.height
);

const newWidth = Math.max(10, resizeStart.width * scale);
const newHeight = Math.max(10, resizeStart.height * scale);
```

**Test Gate:**
1. Lock a shape
2. Grab top-left corner handle ‚Üí drag inward/outward
3. Verify shape resizes proportionally (aspect ratio maintained)
4. Log aspect ratio: `console.log(width / height)` ‚Üí should stay constant
5. Test each corner independently:
   - TL: drag up-left (shrink) and down-right (grow)
   - TR: drag up-right (shrink width, grow height)
   - BL: drag down-left (grow width, shrink height)
   - BR: drag down-right (grow both)
6. Try to make shape tiny ‚Üí should stop at 10√ó10 minimum
7. Visual inspection: shape maintains aspect ratio during entire drag

**Success Criteria:**
- All 4 corner handles work
- Aspect ratio maintained (width/height ratio constant)
- Minimum 10√ó10 enforced
- Smooth visual feedback during drag
- Anchor point stays fixed (opposite corner doesn't move)

**üêõ Debug Notes - Cursor Lock Issue:**

**Problem:** During resize, the cursor would drift away from the handle being dragged, making it feel disconnected and hard to control.

**Root Cause:** The original implementation calculated deltas (dx, dy) from the initial cursor position and used those to scale the shape. This approach caused the cursor position to not match the handle position during the drag.

**Solution (multiple iterations to debug):**
1. **First attempt:** Tried to fix delta calculations - didn't work because the fundamental approach was wrong
2. **Second issue discovered:** Handles disappeared during resize (`!isResizing` condition), so cursor couldn't be "locked" to invisible handles
3. **Third issue discovered:** Preview was transparent, making it impossible to see the shape when resizing smaller

**Final Fix (3 changes):**
1. **Cursor lock logic:** Changed from delta-based to absolute positioning
   - Define the anchored corner (opposite of handle being dragged)
   - Calculate dimensions directly from cursor position to anchor point
   - Handle position = cursor position (no drift!)
   ```typescript
   // Example for BR (bottom-right) corner:
   const anchorX = resizeStart.shapeX;  // Anchor at top-left
   const anchorY = resizeStart.shapeY;
   
   let rawWidth = canvasX - anchorX;   // Cursor defines the corner directly
   let rawHeight = canvasY - anchorY;
   ```

2. **Original shape visibility:** Made original shape semi-transparent (20% opacity) during resize so preview is visible

3. **Preview visibility:** Changed preview from transparent to shape's actual color at 60% opacity with visible handles that follow the cursor

**Key Insight:** The handle should follow the cursor exactly - calculate the shape dimensions FROM the cursor position, not calculate cursor offset from shape dimensions.

---

### Task 1.4: Edge Handle Resize Logic (Single Dimension) ‚úÖ COMPLETED
**Estimated time:** 45 minutes

**Implementation:**
- Top/Bottom handles: resize height only, keep width constant
- Left/Right handles: resize width only, keep height constant
- Update x/y position when resizing from top/left (anchor opposite edge)
- Different edges require different calculations:
  - **Top:** Anchor bottom, decrease y, increase height (total height stays anchored to bottom)
  - **Bottom:** Anchor top, increase height
  - **Left:** Anchor right, decrease x, increase width (total width stays anchored to right)
  - **Right:** Anchor left, increase width

**Resize calculation examples:**
```typescript
// Top edge: resize height, adjust y position
const dy = currentY - resizeStart.y;
const newHeight = Math.max(10, resizeStart.height - dy);
const newY = resizeStart.y + (resizeStart.height - newHeight);
const newWidth = resizeStart.width; // unchanged

// Right edge: resize width only
const dx = currentX - resizeStart.x;
const newWidth = Math.max(10, resizeStart.width + dx);
const newHeight = resizeStart.height; // unchanged
const newX = resizeStart.x; // unchanged
const newY = resizeStart.y; // unchanged
```

**Test Gate:**
1. Lock a shape
2. Grab top edge handle ‚Üí drag up/down
3. Verify: height changes, width stays constant
4. Verify: shape doesn't jump (bottom edge stays anchored)
5. Test left edge ‚Üí width changes, height constant, right edge anchored
6. Test right edge ‚Üí width changes, height constant, left edge anchored
7. Test bottom edge ‚Üí height changes, width constant, top edge anchored
8. Try to make shape too small (< 10px) ‚Üí should stop at minimum
9. Visual inspection: opposite edge stays fixed during entire drag

**Success Criteria:**
- All 4 edge handles work
- Only one dimension changes (width OR height, not both)
- Minimum 10px enforced for changed dimension
- Anchor edge stays fixed (shape doesn't jump around)
- Smooth visual feedback

---

### Task 1.5: Dimension Tooltip During Resize ‚úÖ COMPLETED
**Estimated time:** 30 minutes
**Status:** ‚úÖ Implemented - ready for testing

**Implementation:**
- Show tooltip above shape during resize
- Format: "200 √ó 150" (width √ó height in pixels)
- Position: centered above shape, 30px gap (scaled with zoom)
- Style: white background, gray border, rounded corners, subtle shadow
- Update in real-time during drag
- Hide on mouseup
- All dimensions scale inversely with zoom for consistent visibility

**What was implemented:**
```typescript
{/* Dimension tooltip - shows current dimensions during resize */}
<Group
  x={previewDimensions.x + previewDimensions.width / 2}
  y={previewDimensions.y - (30 / stageScale)}
>
  <Rect
    x={-(60 / stageScale)}
    y={-(20 / stageScale)}
    width={120 / stageScale}
    height={40 / stageScale}
    fill="white"
    stroke="#999"
    strokeWidth={1 / stageScale}
    cornerRadius={6 / stageScale}
    shadowBlur={8 / stageScale}
    shadowOpacity={0.3}
    shadowOffsetY={2 / stageScale}
  />
  <Text
    text={`${Math.round(previewDimensions.width)} √ó ${Math.round(previewDimensions.height)}`}
    fontSize={16 / stageScale}
    fill="#333"
    align="center"
  />
</Group>
```

**Key features:**
- Tooltip only appears when `isResizing` is true and `previewDimensions` exists
- Positioned centered above shape (x: middle of width, y: above shape with gap)
- Uses √ó symbol (multiplication sign, not letter x) for proper formatting
- All dimensions scale with `1 / stageScale` so tooltip stays same size on screen regardless of zoom
- Updates in real-time as `previewDimensions` changes during drag
- Automatically disappears when resize ends (isResizing becomes false)

**Test Gate:**
1. Lock a shape
2. Start dragging any resize handle
3. Verify tooltip appears above shape
4. Verify format: "200 √ó 150" with √ó symbol (not x)
5. Drag handle ‚Üí tooltip values update in real-time
6. Verify values match visible shape dimensions
7. Release handle ‚Üí tooltip disappears immediately
8. Test with corner handle ‚Üí both dimensions update
9. Test with edge handle ‚Üí only one dimension updates

**Success Criteria:**
- Tooltip visible during resize
- Position centered above shape
- Real-time dimension updates
- Correct format (width √ó height)
- Disappears on mouseup
- Readable styling (good contrast, shadow for visibility)

---

### Task 1.6: Persist Resize to Firestore
**Estimated time:** 30 minutes

**Implementation:**
- On mouseup, call `canvasService.resizeShape()` with final dimensions
- Handle errors gracefully (toast notification)
- Clear resize state after successful save
- Unlock shape after resize

**Handler implementation:**
```typescript
const handleResizeEnd = async () => {
  if (!isResizing || !previewDimensions || !selectedShapeId) {
    setIsResizing(false);
    setActiveHandle(null);
    setResizeStart(null);
    setPreviewDimensions(null);
    return;
  }

  try {
    await canvasService.resizeShape(
      selectedShapeId,
      previewDimensions.width,
      previewDimensions.height
    );
    
    // Also update position if it changed (for top/left edge resizes)
    if (previewDimensions.x !== resizeStart!.x || previewDimensions.y !== resizeStart!.y) {
      await updateShape(selectedShapeId, {
        x: previewDimensions.x,
        y: previewDimensions.y
      });
    }
    
    toast.success('Shape resized', { duration: 1000 });
  } catch (error) {
    console.error('‚ùå Failed to resize shape:', error);
    toast.error('Failed to resize shape');
  } finally {
    setIsResizing(false);
    setActiveHandle(null);
    setResizeStart(null);
    setPreviewDimensions(null);
    
    // Unlock shape after resize
    await unlockShape(selectedShapeId);
    setSelectedShapeId(null);
  }
};
```

**Test Gate:**
1. Lock a shape
2. Resize using any handle
3. Release mouse ‚Üí verify Firestore document updated
4. Check Firestore console:
   - `width` field matches final dimension
   - `height` field matches final dimension
   - `updatedAt` timestamp changed
5. Open second browser window (User B)
6. User A resizes shape ‚Üí User B sees update within 100ms
7. Measure sync latency: should be <100ms
8. Test with corner handle (both dimensions change)
9. Test with edge handle (one dimension changes)
10. Test with top/left edge (position also changes)

**Success Criteria:**
- Firestore updates on mouseup
- Both width and height saved correctly
- Position saved when top/left edges used
- Real-time sync works (<100ms for User B)
- Error handling prevents crashes
- Shape unlocked after resize
- Toast notification confirms success

---

## Integration Points

### Existing Features Used:
1. **Locking System** - Resize only works on locked shapes (already implemented)
2. **Canvas Context** - Uses existing shape state and update methods
3. **Konva Rendering** - Handles are rendered as Konva shapes
4. **CanvasService** - New resize method integrates with existing update pattern

### Real-time Sync:
- Firestore `onSnapshot` listener automatically syncs resized shapes to other users
- No additional sync code needed beyond calling `updateDoc`

---

## Success Criteria

### Functional Requirements:
- ‚úÖ 8 resize handles appear when shape locked (4 corners + 4 edges)
- ‚úÖ Corner handles resize proportionally (aspect ratio maintained)
- ‚úÖ Edge handles resize single dimension only
- ‚úÖ Minimum 10√ó10 enforced (toast shown if violated)
- ‚úÖ Dimension tooltip shows during drag ("200 √ó 150")
- ‚úÖ User A resizes ‚Üí User B sees in <100ms
- ‚úÖ Shape position updates correctly when top/left edges used
- ‚úÖ No console errors during resize operations

### Visual Requirements:
- ‚úÖ Handles: 16px white squares with gray border (scales inversely with zoom)
- ‚úÖ Hover: 20px blue squares
- ‚úÖ Handles maintain consistent screen size regardless of zoom level
- ‚úÖ Correct cursor for each handle (nwse-resize, ns-resize, ew-resize, nesw-resize)
- ‚úÖ Smooth preview during drag (no jank)
- ‚úÖ Tooltip readable and well-positioned

### Performance Requirements:
- ‚úÖ 60 FPS maintained during resize
- ‚úÖ Sync latency <100ms
- ‚úÖ No memory leaks (event listeners cleaned up)

---

## Testing Plan

### Manual Testing Steps:
1. **Basic Resize**
   - Create rectangle
   - Lock it
   - Verify 8 handles appear
   - Drag each handle
   - Verify resize works

2. **Corner Resize (Proportional)**
   - Create 200√ó100 rectangle (aspect ratio 2:1)
   - Lock it
   - Drag BR corner to make it bigger
   - Measure final dimensions: should maintain 2:1 ratio
   - Try all 4 corners

3. **Edge Resize (Single Dimension)**
   - Create rectangle
   - Lock it
   - Drag top edge ‚Üí only height changes
   - Drag right edge ‚Üí only width changes
   - Try all 4 edges

4. **Minimum Size Enforcement**
   - Create small rectangle
   - Lock it
   - Try to resize to < 10√ó10
   - Should stop at 10√ó10
   - Toast error shown

5. **Multi-User Sync**
   - Open 2 browser windows
   - User A: Create and lock rectangle
   - User A: Resize to 300√ó200
   - User B: Verify resize appears within 100ms
   - Test with both corner and edge resizes

6. **Performance**
   - Create rectangle
   - Lock and resize rapidly
   - Verify no lag or jank
   - Check browser FPS (should be 60)
   - Verify smooth tooltip updates

### Edge Cases:
1. Resize while other user has shape locked ‚Üí should show lock error
2. Resize near canvas edge ‚Üí shape should stay within bounds
3. Rapid resize movements ‚Üí should handle smoothly
4. Very small starting size ‚Üí minimum enforced
5. Very large resize ‚Üí should work up to canvas limits

---

## Deployment Checklist

Before merging:
- [ ] All 6 sub-tasks completed
- [ ] Manual testing passed
- [ ] Multi-user testing passed (2+ browsers)
- [ ] No console errors
- [ ] 60 FPS performance verified
- [ ] Code reviewed for quality
- [ ] No TypeScript errors
- [ ] Git commit message clear
- [ ] Branch merged to main
- [ ] Deployed to production
- [ ] Production testing completed

---

## Estimated Timeline

| Task | Estimated Time | Notes |
|------|----------------|-------|
| 1.1 CanvasService method | 20 min | Straightforward Firestore update |
| 1.2 Render 8 handles | 30 min | Expand existing 4-handle system |
| 1.3 Corner resize logic | 45 min | Aspect ratio calculations |
| 1.4 Edge resize logic | 45 min | Position adjustment for top/left |
| 1.5 Dimension tooltip | 30 min | Konva Group with Rect + Text |
| 1.6 Persist to Firestore | 30 min | Wire up handlers, error handling |
| **Testing & Polish** | 30 min | Multi-user testing, edge cases |
| **TOTAL** | **3.5 hours** | Single focused PR |

---

## Notes

- This PR builds on existing locking system from MVP
- Visual-only handles already exist (4 corners), we're making them functional + adding 4 edge handles
- Resize preview uses same pattern as drawing preview (dashed rect)
- No new dependencies needed
- Compatible with existing shape drag functionality
- Foundation for future rotation feature (PR #2)
- **Zoom-intelligent handles** implemented in Task 1.2 - reference this pattern for future UI elements (see backlog.md for cursor enhancement)

---

## Ready to Proceed?

Review this action plan and confirm:
1. Approach makes sense?
2. Time estimate realistic (3.5 hours)?
3. Any concerns with implementation strategy?
4. Ready to start implementation?

If approved, I'll begin with Task 1.1 (CanvasService method) and work through systematically. üöÄ
